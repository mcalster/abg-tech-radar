<!DOCTYPE html><html><head><title>test</title><meta charset="utf-8"><style>body {
                font-family: Helvetica, Arial;
                display: block;
                max-width: 1000px;
                margin: 0 auto;
            }
            .title {
                font-size: 20pt;
                margin: 25px 0;
            }
            .date {
                padding: 0;
                font-size: 12px;
                margin: -23px 0 40px 0;
                display: block;
                color: #999;
            }
            header, main {
                display: inline-block;
            }
            header, main, table, tbody, thead {
                width: 100%;
                margin: 0;
                padding: 0;
            }

            table {
                border-spacing: 0;
                font-size: 13px;
            }
            th, td {
                padding: 0 30px 15px 0;
                margin: 0;
                text-align: left;
                vertical-align: top;
            }
            th {
                font-weight: normal;
                padding-bottom: 10px;
                color: #999;
            }
            tr th {
                border-bottom: 1px solid #DDD;
            }

            tbody tr:first-child td {
                padding-top: 20px;
            }

            hr {
                height: 1px;
                border: none;
                color: #DDD;
                background-color: #DDD;
                margin: 40px 0 20px 0;
            }</style></head><body><header><h1 class="title">QIWI iOS Tech Radar</h1><p class="date">2023-03-16</p></header><main><table><thead><tr><th>Name</th><th>Ring</th><th>Quadrant</th><th>Description</th></tr></thead><tbody><tr><td><b>.NET 6</b></td><td>hold</td><td>Languages & Frameworks</td><td><a href="https://dotnet.microsoft.com/">.NET 6</a> is in Long Term Support (LTS). It's fine to keep it for some time, but we should strive to update all our actively developed products to the Latest version.</td></tr><tr><td><b>.NET 7</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://dotnet.microsoft.com/">.NET 7</a> is the Latest version of .NET. It is cross-platform and a great choice for desktop, web and cloud-based applications.</td></tr><tr><td><b>AI/ML</b></td><td>adopt</td><td>Methods & Techniques</td><td>AI/ML are becoming commoditized. Off-the-shelf software is available for predictive modelling, text analysis, anomaly detection and much more.</td></tr><tr><td><b>Airflow</b></td><td>trial</td><td>Tools</td><td>TBC</td></tr><tr><td><b>Apex</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_intro_what_is_apex.htm">Apex</a> is our language for development on the Salesforce platform. For general purpose developement Java & Spring Boot is the default.</td></tr><tr><td><b>Asynchronous state management in React</b></td><td>adopt</td><td>Methods & Techniques</td><td>Asynchronous state management in React should be delegated to a third-party framework such as <a href="https://tanstack.com/query/v4/docs/overview">react-query</a>. This avoids manual management of promises' states (e.g. loading/errors), and allows using suspense and error boundaries in modern React.</td></tr><tr><td><b>Automated code style settings</b></td><td>adopt</td><td>Methods & Techniques</td><td>Codebases should be formatted consistently. Automated code-style settings achieve this without fuss.</td></tr><tr><td><b>Automation/Low-code solutions</b></td><td>assess</td><td>Methods & Techniques</td><td>Remote is driving a digital transformation across industries. Low-code solutions, such as Power Apps, allow organizations to modernize these processes.</td></tr><tr><td><b>Axon</b></td><td>assess</td><td>Languages & Frameworks</td><td><a href="https://developer.axoniq.io/">Axon</a>) is an abstraction layer for use in a Domain Driven Design development methodology. Axon provides a unified, productive way of developing Java applications that can evolve without significant refactoring from a monolith to Event-Driven microservices.</td></tr><tr><td><b>Azure App Configuration</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>We recommend <a href="https://learn.microsoft.com/en-us/azure/azure-app-configuration/concept-feature-management">Azure App Configuration</a> for storing configurations and feature flagging.</td></tr><tr><td><b>Azure App Service</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>TBC</td></tr><tr><td><b>Azure Application Insights</b></td><td>adopt</td><td>Tools</td><td>All applications should use Application Insights as the default developer telemetry platform (incl. feature usage and error reporting).</td></tr><tr><td><b>Azure Data Factory</b></td><td>adopt</td><td>Tools</td><td>TBC</td></tr><tr><td><b>Azure Databricks</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>TBC</td></tr><tr><td><b>Azure DevOps</b></td><td>hold</td><td>Tools</td><td>We expect Microsoft will prioritize GitHub Actions over Azure DevOps for future development, so Azure DevOps is not recommended for new projects.</td></tr><tr><td><b>Azure Event Hubs</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>TBC</td></tr><tr><td><b>Azure Functions</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>TBC</td></tr><tr><td><b>Azure Key Vault</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>We recommend <a href="https://learn.microsoft.com/da-dk/azure/key-vault/general/overview">Azure Key Vault</a> for storing secrets.</td></tr><tr><td><b>Azure Monitor</b></td><td>adopt</td><td>Tools</td><td>All applications should use Application Monitor as the central logging platform (incl. alerting on usage and error reporting).</td></tr><tr><td><b>Azure PostgreSQL as backing store</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>If there's a very good reason to use a lightweight/free database engine, we should choose Postgres.</td></tr><tr><td><b>Azure Purview</b></td><td>adopt</td><td>Tools</td><td>TBC</td></tr><tr><td><b>Azure SQL</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>When a product needs to store more complex data than it can fit in a flat file, we ask the customer for a SQL DB.</td></tr><tr><td><b>Azure Service Bus</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>TBC</td></tr><tr><td><b>Azure Spring Apps</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>TBC</td></tr><tr><td><b>Azure Storage Accounts as backing store</b></td><td>adopt</td><td>Platforms & Infrastructure</td><td>If there's a reason to use a highly scalable blob store, we should choose Azure storage Accounts. E.g. Large files, sftp access, datalake.</td></tr><tr><td><b>Bash</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://www.gnu.org/software/bash/">Bash</a> is our default choice for scripting internal tools. Everyone should be familiar with the Bash toolkit.</td></tr><tr><td><b>Build inside Docker containers</b></td><td>adopt</td><td>Methods & Techniques</td><td>We should reduce build dependencies by building and testing our products inside containers. This is a pre-requisite for performing builds on cloud based CI providers, e.g. GitHub</td></tr><tr><td><b>C#</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://docs.microsoft.com/en-us/dotnet/csharp/">C#</a> is our language for development on the Optimizely platform. For general purpose developement Java & Spring Boot is the default.</td></tr><tr><td><b>CLIs</b></td><td>adopt</td><td>Methods & Techniques</td><td>Product should, where possible, expose functionality via a CLI.</td></tr><tr><td><b>Consul</b></td><td>hold</td><td>Platforms & Infrastructure</td><td>We are moving of Consul toward Azure App Configuration.</td></tr><tr><td><b>Continuous Deployment</b></td><td>assess</td><td>Methods & Techniques</td><td>We'd like to evaluate technology that increases our deployment frequency, with a view to getting value into the hands of our users as quickly as possible.</td></tr><tr><td><b>Continuous delivery</b></td><td>adopt</td><td>Methods & Techniques</td><td>Products should be ready for release at any time.</td></tr><tr><td><b>DAPR</b></td><td>assess</td><td>Languages & Frameworks</td><td>DAPR (Distributed Application Runtime - <a href="https://dapr.io/">https://dapr.io/</a>) is an abstraction layer for use in a distributed application, currently being trialled by Platform for both Hosted and Enterprise. It is used to standardise how to communicate external systems in such a way we can uniformly add features through the DAPR sidecar</td></tr><tr><td><b>Database Agnosticism</b></td><td>adopt</td><td>Methods & Techniques</td><td>We aim for feature parity between products that support different database engines.</td></tr><tr><td><b>Docker</b></td><td>adopt</td><td>Tools</td><td>Docker should be used as the default containerisation technology. Used for building, testing and deployment.</td></tr><tr><td><b>Domain Driven Design</b></td><td>assess</td><td>Methods & Techniques</td><td>Domain-Driven Design (DDD) defines many concepts and patterns that help design software effectively, in line with the business requirements.</td></tr><tr><td><b>Feature Flagging</b></td><td>adopt</td><td>Tools</td><td>If your usage of feature flagging becomes sufficiently complicated then it's time to use <a href="https://learn.microsoft.com/en-us/azure/azure-app-configuration/concept-feature-management">Azure App Configuration</a>.</td></tr><tr><td><b>Feature Flags</b></td><td>adopt</td><td>Methods & Techniques</td><td>Feature Flags are a great technique for minimizing long-lived feature branches. Our recommendation is to focus on simplicity - if you find yourself writing substantial code to support Feature Flags, consider using a third-party solution.</td></tr><tr><td><b>Flyway</b></td><td>adopt</td><td>Tools</td><td>Our default tool for migrating database schemas.</td></tr><tr><td><b>Git Ops</b></td><td>assess</td><td>Methods & Techniques</td><td>The core idea of GitOps is having a Git repository that always contains declarative descriptions of the infrastructure currently desired in the production environment and an automated process to make the production environment match the described state in the repository. If you want to deploy a new application or update an existing one, you only need to update the repository - the automated process handles everything else. It’s like having cruise control for managing your applications in production. <a href="https://www.gitops.tech/">Read more</a>, currently being trialled for Platform Hosted</td></tr><tr><td><b>GitHub</b></td><td>adopt</td><td>Tools</td><td>All development should use GitHub.</td></tr><tr><td><b>Github Actions</b></td><td>adopt</td><td>Tools</td><td>Github Actions is our default build system.</td></tr><tr><td><b>Github Advanced Security</b></td><td>assess</td><td>Tools</td><td>We could use GHAS to scan for known vulnerabilities in our products' dependencies.</td></tr><tr><td><b>Gitlab CI</b></td><td>hold</td><td>Tools</td><td>Gitlab CI is our legacy build system.</td></tr><tr><td><b>Go</b></td><td>hold</td><td>Languages & Frameworks</td><td><a href="https://golang.org/">Go</a> is the natural language to use when writing cloud native software. We depriotize this language until we can achieve critical mass.</td></tr><tr><td><b>GraphQL</b></td><td>assess</td><td>Tools</td><td><a href="https://github.com/facebook/graphql">GraphQL</a> Could be used for some interesting patterns of use, including GraphQL for server-side resource aggregation. That said, there are concerns about misuse of this framework and some of the problems that can occur. Examples include performance gotchas around N+1 queries and lots of boilerplate code needed when adding new models, leading to complexity.</td></tr><tr><td><b>Graphana</b></td><td>hold</td><td>Tools</td><td>We are moving of Grapaha towards Azure Monitor.</td></tr><tr><td><b>Hashicorp Vault</b></td><td>hold</td><td>Tools</td><td>Use a password manager (or Azure Key Vault) instead.</td></tr><tr><td><b>Infrastructure as code</b></td><td>adopt</td><td>Methods & Techniques</td><td>Infrastructure should be provisioned through code rather than manually (except for ad-hoc testing)</td></tr><tr><td><b>JDBC</b></td><td>adopt</td><td>Tools</td><td>Database connectivity for Java.</td></tr><tr><td><b>Java 11/17</b></td><td>adopt</td><td>Languages & Frameworks</td><td>We are currently in the process of test running updating our Java version for new developments in our Java projects</td></tr><tr><td><b>Java 8</b></td><td>hold</td><td>Languages & Frameworks</td><td>We are moving to the newer versions of java. No new development should be started.</td></tr><tr><td><b>Jenkins</b></td><td>hold</td><td>Tools</td><td>Is our legacy Build system. Is moving to Github</td></tr><tr><td><b>Kubernetes</b></td><td>hold</td><td>Platforms & Infrastructure</td><td>Granted <a href="https://kubernetes.io/">K8S</a> is the undeniable winner of orchestration tools. We don't want the managment overhead a K8S cluster an prefer higher level PaaS services such as Azure App Service or Spring Apps</td></tr><tr><td><b>Node.js</b></td><td>assess</td><td>Languages & Frameworks</td><td><a href="https://docs.microsoft.com/en-us/dotnet/csharp/">C#</a> is our language for development on the Optimizely platform. For general purpose developement Java & Spring Boot is the default.</td></tr><tr><td><b>Object–relational mappers (ORMs)</b></td><td>hold</td><td>Languages & Frameworks</td><td>Unless working with a large number of simple entities, prefer writing SQL directly or using a lightweight object mapper such as <a href="https://github.com/DapperLib/Dapper">Dapper</a>.</td></tr><tr><td><b>Oracle ADF</b></td><td>hold</td><td>Languages & Frameworks</td><td>Oracle ADF is an Oracle based dialect of Java Server Faces. No new development should be started.</td></tr><tr><td><b>Oracle FORMs</b></td><td>hold</td><td>Languages & Frameworks</td><td>Oracle FORMS is the technoly used to build the front-end for TIA. No new development should be started.</td></tr><tr><td><b>Oracle OSB</b></td><td>hold</td><td>Platforms & Infrastructure</td><td>Oracle Service Bus is an Oracle based Enterprise Service Bus. We are moving towards Spring Boot and Azure. No new development should be started.</td></tr><tr><td><b>Oracle SOA</b></td><td>hold</td><td>Platforms & Infrastructure</td><td>Oracle SOA is an Oracle based BPM engine.We are moving towards Spring Boot and Azure. No new development should be started.</td></tr><tr><td><b>Oracle Weblogic</b></td><td>hold</td><td>Platforms & Infrastructure</td><td>Oracle Weblogic is an Oracle developed Web server used for serving ADF and FORMS applications. We are moving towards Spring Boot and Azure. No new development should be started.</td></tr><tr><td><b>PL/SQL</b></td><td>hold</td><td>Languages & Frameworks</td><td>PL/SQL is a standard and portable language for Oracle Database development. It is our language for development on the TIA system running on the Oracle Database</td></tr><tr><td><b>PowerShell</b></td><td>hold</td><td>Languages & Frameworks</td><td>Don't use PowerShell for new projects - prefer Bash.</td></tr><tr><td><b>Project Lombok</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://projectlombok.org/">Project Lombok</a> is a Java code enhancement for introducing a set of tools to reduce boiler plating and increase developer efficiency and allowing for a more C# style of coding to help on-board new developers from the wider Red Gate environment</td></tr><tr><td><b>Prometheus</b></td><td>hold</td><td>Tools</td><td>We are moving of Prometheus toward Azure Monitor.</td></tr><tr><td><b>Python</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://www.python.org/">Python</a> provides a powerful language for gluing components together. We encourage trialling Python when the alternative would be a large Bash script (caveated by why isn't it easy to write a Bash script?).</td></tr><tr><td><b>R</b></td><td>hold</td><td>Languages & Frameworks</td><td></td></tr><tr><td><b>RESTful APIs</b></td><td>adopt</td><td>Methods & Techniques</td><td>A REST architectural style is our default choice for building web APIs. Deviations can be made when it makes sense to do so.</td></tr><tr><td><b>RabbitMQ</b></td><td>hold</td><td>Platforms & Infrastructure</td><td>We are moving of RabbitMQ toward Azure Service Bus for 'Queues' and Azure Event Hub for 'Topics'. No new development should be started.</td></tr><tr><td><b>React</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://reactjs.org/">React</a> makes it painless to create interactive UIs.</td></tr><tr><td><b>Semantic Versioning</b></td><td>adopt</td><td>Methods & Techniques</td><td>We should use semver for all our versioning needs unless there's a compelling reason not to.</td></tr><tr><td><b>Serena Dimensions</b></td><td>hold</td><td>Tools</td><td>Serena Dimensions is being replaced by Github</td></tr><tr><td><b>Snyk</b></td><td>assess</td><td>Tools</td><td>We could use Snyk to scan for known vulnerabilities in our products' dependencies.</td></tr><tr><td><b>Spring Boot</b></td><td>adopt</td><td>Languages & Frameworks</td><td>Spring Boot allows easy setup of standalone Spring-based applications. It's ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain, thanks to the JPA mappings through Spring Data. We like that Spring Boot simplifies Java services built with Spring</td></tr><tr><td><b>Static code analysis (linters)</b></td><td>adopt</td><td>Methods & Techniques</td><td>Static code analysis is invaluable for automatically checking for problems in code. We use ESLint for JS and Roslyn-based analyzers for .NET. We also experimented with SonarQube but our implementation wasn't giving us confidence.</td></tr><tr><td><b>Terraform</b></td><td>adopt</td><td>Tools</td><td>Used for automating infrastructure provisioning.</td></tr><tr><td><b>TypeScript</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://www.typescriptlang.org/">TypeScript</a> is our default choice for running code in the browser. It's strongly-typed and smoothes out the rough bits of JavaScript.</td></tr><tr><td><b>VS Code</b></td><td>adopt</td><td>Tools</td><td>A free lightweight IDE. Our text editor of choice.</td></tr><tr><td><b>Virtual Machines</b></td><td>hold</td><td>Platforms & Infrastructure</td><td>Prefer using higher level PaaS services.</td></tr><tr><td><b>Visual Studio</b></td><td>adopt</td><td>Tools</td><td>Visual Studio is our default IDE for developing in C#. We get the Enterprise edition via our MSDN subscription.</td></tr><tr><td><b>WSL 2</b></td><td>adopt</td><td>Tools</td><td>Windows Subsystem for Linux should be installed on every development machine</td></tr><tr><td><b>Web API (ASP.NET Core)</b></td><td>adopt</td><td>Languages & Frameworks</td><td><a href="https://learn.microsoft.com/en-us/aspnet/core/web-api">ASP.NET Core Web API</a> for building RESTful APIs on .NET</td></tr><tr><td><b>WebFLux</b></td><td>hold</td><td>Languages & Frameworks</td><td></td></tr><tr><td><b>gRPC</b></td><td>assess</td><td>Tools</td><td><a href="https://grpc.io/">gRPC</a> is a high-performance RPC framework which we may investigate for high-volume data collection (for example, SQL Monitor).</td></tr><tr><td><b>jUnit 5</b></td><td>adopt</td><td>Languages & Frameworks</td><td>Test framework for Java code</td></tr></tbody></table></main><hr><style>.legend li {
  margin: 25px 50px 0 0;
}

.legend table {
  width: 1000px;
  margin: 0;
  font-size: 80%;
}

.legend td {
  width: 50%;
  vertical-align: top;
  padding-right: 60px;
}</style><div class="legend"><table><tr><td><h3>Технологический радар</h3><span>Удобный инструмент, помогающий компании управлять своей платформой разработки и технологической стратегией. Радар объединяет используемые технологии в четыре категории: техники, языки и фреймворки, инструменты и платформы. Каждая из этих областей ранжируется по стадии внедрения:</span><ul><li><strong>ADOPT</strong> &mdash; технологии, в которых мы уверены, и рекомендованы к широкому использованию в QIWI, соответствуют культуре и целям компании.</li><li><strong>TRIAL</strong> &mdash; новый стек, используемый лишь в отдельных проектах для оценки рисков перед массовым внедрением.</li><li><strong>ASSESS</strong> &mdash; блидин эдж, ёрли превью, всякие экспериментальные штуки, потенциально имеющие ценность.</li><li><strong>HOLD</strong> &mdash; депрекейтед легаси. Отжившие свой век технологии, которые не рекомендуется использовать для новых проектов, но допустимо сохранять в старых.</li></ul></td><td><h3>Цели</h3><ul><li>Держать под контролем свои компетенции. Подготовка радара — это анализ происходящего — способ посмотреть в какую сторону движется индустрия, и как общие тренды соотносятся с нашим зоопарком.</li><li>Принимать правильные архитектурные решения. У команд появляется источник информации о том, какие решения рекомендуется использовать для тех или иных целей.</li></ul><br><br><h3>Наполнение</h3><span>Технический радар поддерживается разработчиками в формате холивара. В нем отражены наши стремления, успехи и ошибки.</span></td></tr></table><legend><footer><div style="width: 100%; text-align: center; margin: 30px 0 10px 0; font-size: 80%"><a href="https://github.com/qiwi/tech-radar">Tech-radar generator</a>. Based on <a href="https://github.com/zalando/tech-radar">zalando/tech-radar</a>. Boosted with <a href="https://github.com/11ty/eleventy/">11ty</a><br><a class="link" href="https://github.com/qiwi">QIWI ❤️ Open Source</a></div></footer></legend></div></body></html>